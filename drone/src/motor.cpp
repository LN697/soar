#include "motor.h"
#include <cmath>
#include <iostream>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

Motor::Motor(const MotorParams& params) : params(params) {
    state_omega = 0.0;
    state_current = 0.0;
    state_temp = 293.15;
}

std::pair<Scalar, Scalar> Motor::step(Scalar dt, Scalar v_in) {
    // --- 1. Electrical Model ---

    // Back-EMF (Electromotive Force) opposes the input voltage.
    // It is proportional to angular velocity.
    // Kv is usually RPM/Volt. Convert to rad/s/Volt for SI calculations.
    // Ke (Back-EMF constant) is roughly 1/Kv_SI.
    double Kv_SI = params.Kv * (2.0 * M_PI / 60.0); 
    double Ke = 1.0 / Kv_SI; 

    // Calculate Back-EMF voltage
    double back_emf = state_omega * Ke;

    // Ohm's Law: V_net = I * R -> I = (V_in - V_back) / R
    // Note: We clamp v_in to be non-negative for this simple model, 
    // though reversible ESCs exist.
    double voltage_net = v_in - back_emf;
    
    // Update current state
    state_current = voltage_net / params.Rm;

    // --- 2. Thermal Model (Simplified) ---
    // Heat generated P = I^2 * R
    // This is a placeholder for a more complex thermal model
    // double heat_joules = state_current * state_current * params.Rm * dt;
    // state_temp += heat_joules / (params.mass * params.specific_heat); // Requires mass/heat cap in params

    // --- 3. Mechanical Model ---

    // Torque generated by the motor (Lorentz Force)
    // Kt (Torque constant) is theoretically equal to Ke in SI units.
    double Kt = Ke;
    double torque_motor = Kt * state_current;

    // Counter-Torque (Drag) from the propeller spinning in air.
    // Drag Torque usually scales with the square of speed.
    // dragCoeff here represents the aerodynamic drag of the specific prop attached.
    double torque_drag = params.dragCoeff * state_omega * state_omega;
    
    // Directionality: Drag opposes motion.
    if (state_omega < 0) torque_drag = -torque_drag;

    // Net Torque
    double torque_net = torque_motor - torque_drag;

    // Newton's 2nd Law for Rotation: Tau = I * alpha
    double alpha = torque_net / params.MoI;

    // Integrate Angular Velocity
    state_omega += alpha * dt;

    // Prevent negative speed in this simple uni-directional model
    if (state_omega < 0) state_omega = 0;

    // --- 4. Force Output ---
    
    // Thrust is proportional to RPM squared for static props.
    // We assume a 'thrustCoeff' roughly related to dragCoeff or provided separately.
    // For this demo, let's derive it or add it to params. 
    // Let's assume a standard relation for a 5-inch prop: Thrust ~= k * omega^2
    // We will use a separate constant for clarity.
    double thrustCoeff = 2.0e-5; // Example value, tuning required
    double thrust = thrustCoeff * state_omega * state_omega;

    return {thrust, torque_drag};
}